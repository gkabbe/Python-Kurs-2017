<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>5 - Numpy | Python Kurs 2017</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://gkabbe.github.io/Python-Kurs-2017/vorlesungen/numpy/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Gabriel Kabbe">
<link rel="prev" href="../module_exceptions/" title="4 - Module &amp; Exceptions" type="text/html">
<link rel="next" href="../scipy_matplotlib/" title="Scipy &amp; Matplotlib" type="text/html">
<meta property="og:site_name" content="Python Kurs 2017">
<meta property="og:title" content="5 - Numpy">
<meta property="og:url" content="https://gkabbe.github.io/Python-Kurs-2017/vorlesungen/numpy/">
<meta property="og:description" content="Geht es um numerische Problemstellungen aller Art, ist das Modul Numpy in Python die erste Wahl.
Es erlaubt Matrix- und Vektorberechnungen, und ist damit gerade bei größeren Datenmengen ein gutes Stüc">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-05-05T00:00:00+01:00">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Springe zum Hauptinhalt</a>

<!-- Menubar -->

<nav class="navbar navbar-toggleable-md navbar-inverse bg-inverse static-top mb-4"><div class="container">
<!-- This keeps the margins nice -->
        <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <a class="navbar-brand" href="https://gkabbe.github.io/Python-Kurs-2017/">

            <span id="blog-title">Python Kurs 2017</span>
        </a>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../../vorlesungen" class="nav-link">Vorlesungen</a>
                </li>
<li class="nav-item">
<a href="../../%C3%BCbungen" class="nav-link">Übungen</a>
                </li>
<li class="nav-item">
<a href="../../categories/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS-Feed</a>
                </li>
<li class="nav-item">
<a href="../../about" class="nav-link">Impressum</a>

                
            </li>
</ul>
<ul class="navbar-nav navbar-right">
<li class="nav-item">
    <a href="index.md" id="sourcelink" class="nav-link">Source</a>
    </li>

                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">5 - Numpy</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                    Gabriel Kabbe
            </span></p>
            <p class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2017-05-05T00:00:00+01:00" itemprop="datePublished" title="2017-05-05 00:00">2017-05-05 00:00</time></a></p>
            
        <p class="sourceline"><a href="index.md" id="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>Geht es um numerische Problemstellungen aller Art, ist das Modul Numpy in Python die erste Wahl.
Es erlaubt Matrix- und Vektorberechnungen, und ist damit gerade bei größeren Datenmengen ein gutes Stück schneller als handgeschriebener Python-Code.</p>
<h2>Erste Schritte</h2>
<h3>Erstellen von Numpy-Arrays</h3>
<p>Die meiste Zeit arbeitet man in Numpy mit den sogenannten Numpy-Arrays. Diese verhalten sich ähnlich wie Listen, es lassen sich aber nachträglich keine neuen Elemente hinzufügen.</p>
<h4>Erzeugen eines Arrays aus einer Liste</h4>
<p>Ein Numpy-Array lässt sich leicht aus einer Liste erstellen:</p>
<pre class="code literal-block"><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span>numpy.ndarray
</pre>


<h4>Shape - Die Dimensionen eines Arrays</h4>
<p>Wir haben im obigen Beispiel gesehen, dass das erzeugte Objekt vom Typ ndarray ist.
Ein ndarray kann, wie gezeigt, eine Dimension haben (entspricht einer einfache Liste), durch Schachtelung von Listen können wir aber auch höherdimensionierte Arrays erhalten</p>
<pre class="code literal-block"><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">arr_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mf">9.0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span> <span class="c1"># Liste von Listen -&gt; 2 Dimensionen</span>
<span class="n">shape</span> <span class="o">=</span> <span class="n">arr_2d</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># </span>
<span class="k">print</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">"Anzahl Dimensionen:"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim_len</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">"Dimension"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">"hat Länge"</span><span class="p">,</span> <span class="n">dim_len</span><span class="p">)</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span>(3, 4)
Anzahl Dimensionen: 2
Dimension 0 hat Länge 3
Dimension 1 hat Länge 4
</pre>


<p>Der Tupel shape kann uns für ndarrays anzeigen, wieviele Dimensionen es gibt.</p>
<p>Zu beachten ist übrigens immer, dass alle Listen einer Dimension die selbe Länge haben müssen!</p>
<h4>Erzeugen eines mit Nullen gefüllten Arrays</h4>
<p>Um einen mit Nullen gefüllten Array zu erstellen, benutzen wir die Funktion <em>zeros</em>:</p>
<pre class="code literal-block"><span></span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">arr_zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
</pre>


<h4>Erzeugen eines mit Einsen gefüllten Arrays</h4>
<pre class="code literal-block"><span></span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">arr_ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
</pre>


<h4>Erzeugen einer Zahlenreihe</h4>
<p>Um einen Floatarray zu erzeugen, der zwischen Start- und Endpunkt Werte in regelmäßigen Abständen voneinander enthält, benutzt man <em>linspace</em>:</p>
<pre class="code literal-block"><span></span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> 
<span class="n">size</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</pre>


<h4>Erzeugen von zufälligen Arrays</h4>
<p>Für Integers benutzt man:</p>
<pre class="code literal-block"><span></span><span class="n">start</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">end</span> <span class="o">=</span> <span class="mi">25</span> <span class="c1"># Achtung, end ist nicht enthalten!</span>
<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
</pre>


<p>Für Float:</p>
<pre class="code literal-block"><span></span><span class="n">start</span> <span class="o">=</span> <span class="mf">3.7</span>
<span class="n">end</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="c1"># nicht enthalten!</span>
<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
</pre>


<h3>Datentyp eines Arrays</h3>
<p>Bisher haben wir Numpy-Arrays erzeugt, ohne uns Gedanken darüber zu machen, welchen Datentyp sie eigentlich besitzen.</p>
<p>Den Datentyp können wir uns ansehen, wenn wir das Attribut <em>dtype</em> eines Arrays aufrufen</p>
<pre class="code literal-block"><span></span><span class="k">print</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">arr_2d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">arr_zeros</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span>int64
float64
float64
</pre>


<p>Der Grund für diese Ausgabe: im ersten Beispiel wurde ein Array aus einer Liste mit Integers erzeugt. Daher ist auch der resultierende Datentyp vom Typ Integer. 
Im zweiten Beispiel enthält die zweite Liste am Anfang einen Float, daher bekommt der gesamte Array den Typ Float (die 64 steht dabei für 64 bit, 
der Größe eines einzelnen Elements des Arrays). Und auch <em>zeros</em> erstellt standardmäßig einen Array vom Typen Float.</p>
<p>Möchten wir dieses Verhalten beeinflussen, können wir einfach beim erstellen des Arrays das Keyword <em>dtype</em>=<gew datentyp> mitgeben:</gew></p>
<pre class="code literal-block"><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre>


<p>Ebenso funktioniert das bei den anderen Funktionen zur Erzeugung eines Arrays.</p>
<h3>IO mit Numpy</h3>
<p>Numpy macht es uns sehr einfach, numerische Daten einzulesen. In der Regel (bei gut formatierten Dateien) reicht die Funktion <em>loadtxt</em> aus:</p>
<pre class="code literal-block"><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s2">"dateiname"</span><span class="p">)</span>
</pre>


<p>Genauso kann man <em>savetxt</em> benutzen, um Daten auf die Fesplatte zu schreiben:</p>
<pre class="code literal-block"><span></span><span class="n">arr1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">))</span>
<span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">"random_data"</span><span class="p">,</span> <span class="n">arr1</span><span class="p">)</span>
</pre>


<h3>Rechnen mit Arrays</h3>
<p>Wir fangen in einer Dimension an:</p>
<h4>Addition</h4>
<pre class="code literal-block"><span></span><span class="n">arr1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">arr1</span> <span class="o">+</span> <span class="n">arr2</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span><span class="k">[ 5.  7.  9.]</span>
<span class="na">float64</span>
</pre>


<p>Hier sehen wir, dass die Addition zweier Arrays zu einer elementweisen Addition führt. Da arr2 vom Type float64 ist, ist auch der Array <em>result</em> vom Typ float64.</p>
<h4>Multiplikation</h4>
<p>Was passiert wenn wir die beiden Arrays multiplizieren?</p>
<pre class="code literal-block"><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">arr1</span> <span class="o">*</span> <span class="n">arr2</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span>[  4.  10.  18.]
</pre>


<p>Man sieht, dass auch hier wieder elementweise multipliziert wurde!
Wollen wir stattdessen das Skalarprodukt berechnen, müssen wir auf die Funktion <em>dot</em> zurückgreifen:</p>
<pre class="code literal-block"><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span>32.0
</pre>


<h4>Boolsche Operationen mit Numpy-Arrays</h4>
<p>Auch boolsche Operationen werden elementweise angewandt.</p>
<pre class="code literal-block"><span></span><span class="n">arr1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>

<span class="k">print</span><span class="p">(</span><span class="n">arr2</span> <span class="o">&gt;</span> <span class="n">arr1</span><span class="p">)</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span><span class="k">[[ True  True  True]</span>
 <span class="k">[False False False]</span>
 <span class="k">[ True False False]]</span>
</pre>


<p>Das Ergebnis ist in diesem Beispiel also wieder ein zweidimensionaler Array.</p>
<h4>Weitere elementweise Operationen</h4>
<p>Alle bekannten Funktionen wie cos, sin, exp, ... lassen sich auch in Numpy elementweise auf einen Array anwenden:</p>
<pre class="code literal-block"><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
</pre>


<p>Ausgabe:</p>
<p>viele Zahlen</p>
<h4>Höhere Dimensionen</h4>
<p>Arbeiten wir mit Arrays in höheren Dimensionen, funktioniert bei elementweisen Operationen alles wie in einer Dimension. </p>
<p>Die Funktion <em>dot</em> ermöglicht für zwei Dimensionen Matrix-Multiplikation. Bei Kombination von 2D- und 1D-Arrays wird Matrix-Vektor-Multiplikation angewandt.</p>
<h4>sum, mean und var</h4>
<p>Numpy bringt eigene Methoden mit, um über Arrays zu summieren (sum), sie zu mitteln (mean), oder die Varianz auszurechnen (var).</p>
<p>Einfachstes Beispiel:</p>
<pre class="code literal-block"><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">var</span><span class="p">())</span>
</pre>


<p>mit der Ausgabe</p>
<pre class="code literal-block"><span></span>6
2.0
0.666666666667
</pre>


<p>Liegt der Array in höheren Dimensionen vor, so wird standardmäßig über alle Elemente summiert/gemittelt/die Varianz gebildet. </p>
<p>In manchen Fällen ist das jedoch nicht das, was wir möchten. Wenn wir beispielsweise einen Array mit mehreren 3D-Koordinaten haben, und davon den geometrischen Schwerpunkt berechnen wollen, so müssen wir die x-, y- und z-Koordinaten aller Atome separat mitteln.</p>
<pre class="code literal-block"><span></span><span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
</pre>


<p>Dafür geben wir der mean-Methode noch den zusätzlichen Parameter <em>axis</em> mit. In diesem Fall wäre das die 0. Dimension. Numpy mittelt dann über alle Zeilen des Arrays</p>
<pre class="code literal-block"><span></span><span class="n">geometric_center</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">geometric_center</span><span class="p">)</span>
</pre>


<p>Damit erhalten wir aus dem Array atoms mit der shape (4, 3) einen neuen eindimensionalen Array der shape (3,).</p>
<pre class="code literal-block"><span></span>array([ 4.25,  6.  ,  6.  ])
</pre>


<p>Für axis=1 würde dementsprechend über alle Spalten jeder Zeile gemittelt:</p>
<pre class="code literal-block"><span></span>array([ 6.        ,  8.        ,  2.33333333,  5.33333333])
</pre>


<h3>all und any</h3>
<p>Ähnlich wie sum, mean und var, gibt es für boolsche Arrays die Methoden all und any.
Dabei gibt all True zurück wenn alle Einträge des Arrays True sind.
Any gibt True zurück, falls einer der Einträge True ist.</p>
<p>Auch hier können wir wieder das keyword axis angeben, was zur Folge hat, dass in der angegebenen Dimension überprüft wird, ob alle Einträge/mindestens ein Eintrag True sind, und die Dimension dann auf True oder False reduziert wird.</p>
<p>Beispiel:</p>
<pre class="code literal-block"><span></span><span class="n">bool_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">],</span> 
                       <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">],</span> 
                       <span class="p">[</span><span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">]])</span>

<span class="k">print</span> <span class="p">(</span><span class="n">bool_array</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>  <span class="c1"># True, weil es Einträge im gesamten Array gibt, die True sind</span>
<span class="k">print</span> <span class="p">(</span><span class="n">bool_array</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>  <span class="c1"># False, weil es Einträge gibt, die False sind</span>
<span class="k">print</span><span class="p">(</span><span class="n">bool_array</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># any wird auf jede Spalte angewendet</span>
<span class="k">print</span><span class="p">(</span><span class="n">bool_array</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># any wird auf jede Zeile angewendet</span>
<span class="k">print</span><span class="p">(</span><span class="n">bool_array</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># all wird auf jede Spalte angewendet</span>
<span class="k">print</span><span class="p">(</span><span class="n">bool_array</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># all wird auf jede Zeile angewendet</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span>True
False
[ True  True  True]
[ True  True False]
[False False False]
[False  True False]
</pre>


<h3><a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">Broadcasting</a></h3>
<p>Was passiert wenn wir versuchen, zwei Arrays unterschiedlicher Dimensionen miteinander zu addieren/multiplizieren?</p>
<p>Der einfachste Fall ist, wenn ein Array nur ein einziges Element enthält:</p>
<pre class="code literal-block"><span></span><span class="n">arr1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> 
                 <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>

<span class="k">print</span><span class="p">(</span><span class="n">arr1</span> <span class="o">*</span> <span class="n">arr2</span><span class="p">)</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span><span class="k">[[ 2  4  6]</span>
 <span class="k">[ 8 10 12]]</span>
</pre>


<p>Hier wird jedes Element von arr1 mit 2 multipliziert. Wir können uns vorstellen, dass arr2 auf die Dimension von arr1 vergrößert wurde, um dann schließlich eine Multiplikation zweier Arrays mit gleichen Dimensionen durchzuführen.</p>
<p>arr2 kann aber auch eine komplexere shape haben:</p>
<pre class="code literal-block"><span></span><span class="n">arr1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> 
                 <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="k">print</span><span class="p">(</span><span class="n">arr1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">arr2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">arr1</span><span class="o">*</span><span class="n">arr2</span><span class="p">)</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span>(2, 3)
(1, 3)
[[ 3  8 15]
 [12 20 30]]
</pre>


<p>Was ist hier passiert? Wir sehen, dass beide Arrays zwei Dimensionen haben, wobei die letzten Dimensionen beide die Länge 3 haben. Die nullten Dimensionen haben jedoch unterschiedliche Größen. Numpy kopiert nun einfach die nullte Dimension von arr2 einmal, so dass arr2 identisch ist zu</p>
<pre class="code literal-block"><span></span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> 
          <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
</pre>


<p>Nun kann wieder elementweise gerechnet werden.</p>
<p>Hinweis:</p>
<p>Wir haben arr2 schon direkt mit zwei Dimensionen (zwei geschachtelte Klammern) initialisiert:</p>
<pre class="code literal-block"><span></span><span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
</pre>


<p>Tatsächlich wäre das gar nicht notwendig. Es reicht auch nur eine Dimension:</p>
<pre class="code literal-block"><span></span><span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</pre>


<p>Numpy kann dann immer noch broadcasten. Es fügt einfach solange neue Dimensionen (der Länge 1) hinzu, bis die Anzahl der Dimensionen der beiden Arrays gleich ist. </p>
<p><strong>Allgemein</strong>:
Damit zwei Arrays gebroadcastet werden können, muss folgendes gelten (man fängt dabei an, die Dimensionen von hinten paarweise zu vergleichen): beide Dimensionen haben jeweils die selbe Länge oder eine davon hat die Länge 1.</p>
<p>Beispiel</p>
<p>arr1 hat shape (2, 3, 4, 1, 7, 5)
arr2 hat shape (1, 3, 4, 8, 7, 1)</p>
<p>Diese beiden Arrays können gebroadcastet werden. Der resultierende Array hat dann die Shape (2, 3, 4, 8, 7, 5).</p>
<p>Folgendes Beispiel funktioniert aber nicht:</p>
<p>arr1 hat shape (2, 3, 4, 1, 7, 5)
arr2 hat shape (1, 3, 4, 8, 7, 3)</p>
<p>da die letzten Dimensionen (3 und 5) nicht miteinander kompatibel sind.</p>
<h4>Praktisches Beispiel</h4>
<p>Eine Anwendung ist z.B. das dyadische Produkt (= Produkt aus Spalten- und Zeilenvektor, bei dem eine Matrix entsteht):</p>
<pre class="code literal-block"><span></span><span class="n">arr1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="n">mat</span> <span class="o">=</span> <span class="n">arr1</span> <span class="o">*</span> <span class="n">arr2</span>
</pre>


<p>Was passiert genau? Schauen wir uns die shapes an:</p>
<p>arr1.shape -&gt; (3, 1)</p>
<p>arr2.shape -&gt; (4,)</p>
<ol>
<li>Numpy betrachtet die letzten Dimensionen der beiden Arrays. arr1 hat als letzte Dimensionsgröße 1, arr2 hat 4.
   Numpy macht daraus:</li>
</ol>
<p>arr1: (3, 4) # kopiere die letzte Dimension 4 mal</p>
<p>-&gt;  arr1 wird zu </p>
<p><code>python
   np.array([[1, 1, 1, 1], [3, 3, 3, 3], [2, 2, 2, 2]])</code></p>
<ol>
<li>
<p>Numpy betrachtet die nächste Dimension:
   arr1 hat als vorletzte Dimensionsgröße 3, arr2 hat keine weitere Dimension.
   -&gt; Numpy erweitert die shape von arr2 zu (1, 4)
   Jetzt können die Werte wieder kopiert werden
   -&gt; arr2 wird zu 
   <code>python
   np.array([[2, 1, 0, 3], 
             [2, 1, 0, 3], 
             [2, 1, 0, 3]])</code></p>
</li>
<li>
<p>Jetzt wo beide Arrays die selbe shape haben, kann einfach elementweise multipliziert werden:</p>
</li>
</ol>
<pre class="code literal-block"><span></span>array([[2, 1, 0, 3],
       [6, 3, 0, 9],
       [4, 2, 0, 6]])
</pre>


<h3>Neue Dimensionen zu einem Array hinzufügen</h3>
<p>Wie wir gesehen haben, fügt Numpy beim Broadcasten oft neue Dimensionen ein, so dass elementweise Rechenoperationen ausgeführt werden können. In manchen Fällen müssen zusätzliche Dimensionen jedoch auch manuell eingefügt werden. Dazu folgendes Beispiel:</p>
<pre class="code literal-block"><span></span><span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="n">masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
</pre>


<p>Wir haben einen Array, in dem zeilenweise die Koordinaten von 3 Atomen gespeichert sind, sowie einen Array, der ihre Massen speichert. Da wir den Schwerpunkt berechnen wollen, wollen wir erst jede Atomkoordinate mit dem jeweiligen Gewicht des Atoms multiplizieren und anschließend durch die Gesamtmasse teilen.
Berechnen wir jetzt aber naiv atoms*masses, tut Numpy leider nicht das, was wir wollen. Es multipliziert nun die x-Koordinaten mit der Masse von Atom 1, die y-Koordinaten mit der Masse von Atom 2 und die z-Koordinaten mit der Masse von Atom 3. </p>
<p>Der Grund: masses und atoms werden falsch gebroadcastet. </p>
<p>Shape-Betrachtung:</p>
<p>atoms:  (3, 3)</p>
<p>masses: (3,)</p>
<p>Daraus wird:</p>
<p>atoms:  (3, 3)</p>
<p>masses: (1, 3) # Numpy fügt eine Dimension am Anfang ein!</p>
<p>Und nun wird der Inhalt der hinteren Dimension von masses dreimal kopiert:</p>
<pre class="code literal-block"><span></span><span class="n">masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">],</span>
                   <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">],</span>
                   <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">]])</span>
</pre>


<p>Um das zu verhindern, machen wir folgendes: Wir fügen eine zusätzliche Dimension hinten an masses an:</p>
<pre class="code literal-block"><span></span><span class="n">masses</span> <span class="o">=</span> <span class="n">masses</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> 
<span class="k">print</span> <span class="n">masses</span>
</pre>


<p>masses sieht dann so aus:</p>
<pre class="code literal-block"><span></span>array([[ 1. ],
       [ 1.5],
       [ 2.5]])
</pre>


<p>Wir haben einen Spaltenvektor daraus gemacht!</p>
<p>Und diesmal broadcastet Numpy dann auch richtig: jede Atomkoordinate wird mit der entprechenden Atommasse multipliziert.</p>
<h3>Indexing und Slicing</h3>
<p>Indexing und Slicing funktioniert mit Numpy-Objekten ganz ähnlich wie mit Listen. Der Unterschied ist nun aber, dass auch höhere Dimensionen berücksichtigt werden müssen. </p>
<h4>Indexing</h4>
<pre class="code literal-block"><span></span><span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> 
                <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> 
                <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>

<span class="k">print</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre>


<p>Hier wird also für jede Dimension ein Index angegeben.</p>
<p>Alternativ kann man auch für jede Dimension eine Liste mit Indizes angeben:</p>
<pre class="code literal-block"><span></span><span class="k">print</span><span class="p">(</span><span class="n">mat</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> 
          <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span>[ 4  1 11]
</pre>


<p>Diese Operation könnten wir auch in mehreren einzelnen Schritten ausführen:</p>
<pre class="code literal-block"><span></span><span class="k">print</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],)</span>
<span class="k">print</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],)</span>
<span class="k">print</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre>


<p>Damit konstruieren wir einen neuen Array mit den Werten mat[0, -1], mat[0, 0] und mat[2, 2]</p>
<h4>Slicing</h4>
<pre class="code literal-block"><span></span><span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> 
                <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> 
                <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>

<span class="k">print</span><span class="p">(</span><span class="n">mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># erste Spalte für jede Zeile</span>
<span class="k">print</span><span class="p">(</span><span class="s2">""</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">mat</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># die ersten beiden Zeilen, und davon jeweils die ersten 3 Spalten</span>
</pre>


<p>Ausgabe:</p>
<pre class="code literal-block"><span></span><span class="k">[1 5 9]</span>

<span class="k">[[1 2 3]</span>
 <span class="k">[5 6 7]]</span>
</pre>


<h3>Praktisches Beispiel: Bildbearbeitung</h3>
<p>Das Modul PIL erlaubt uns, Bilder einzulesen, und als Numpy-Array zu bearbeiten.</p>
<p><img src="https://raw.githubusercontent.com/gkabbe/Python-Kurs2015/master/images/numpy/blume.JPG" alt="Blume" width="400" height="300"></p>
<pre class="code literal-block"><span></span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>

<span class="n">pic_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"blume.JPG"</span><span class="p">))</span> <span class="c1"># andere Dateiformate funktionieren auch</span>
</pre>


<p>pic_array ist ein Numpy-Array mit den Dimensionen (höhe, breite, farbkanäle). Bei einem Farbbild haben wir dann 3 Farbkanäle: rot, grün und blau.</p>
<p>Als einfachstes Beispiel können wir nun aus einem Farbbild ein Schwarz-Weiß-Bild machen. Dazu mitteln wir die Werte der 3 Farbkanäle</p>
<pre class="code literal-block"><span></span><span class="n">black_white</span> <span class="o">=</span> <span class="n">pic_array</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="sb">````</span>
<span class="n">Da</span> <span class="n">die</span> <span class="n">Kanäle</span> <span class="ow">in</span> <span class="n">der</span> <span class="n">zweiten</span> <span class="n">Dimension</span> <span class="n">gespeichert</span> <span class="n">sind</span><span class="p">,</span> <span class="n">müssen</span> <span class="n">wir</span> <span class="n">das</span> <span class="n">auch</span> <span class="n">der</span> <span class="n">mean</span><span class="o">-</span><span class="n">Methode</span> <span class="err">ü</span><span class="n">ber</span> <span class="n">das</span> <span class="n">axis</span> <span class="n">keyword</span> <span class="n">mitteilen</span><span class="o">.</span>

<span class="n">Um</span> <span class="n">das</span> <span class="n">neuerhaltene</span> <span class="n">Schwarz</span><span class="o">-</span><span class="n">Weiß</span><span class="o">-</span><span class="n">Bild</span> <span class="n">speichern</span> <span class="n">zu</span> <span class="n">können</span><span class="p">,</span> <span class="n">machen</span> <span class="n">wir</span> <span class="n">folgendes</span><span class="p">:</span>


<span class="sb">``</span><span class="err">`</span><span class="n">python</span>
<span class="n">black_white</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">black_white</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="c1"># Um den Array umwandeln zu können, muss er den dtype uint8 haben</span>
<span class="n">bw_image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">black_white</span><span class="p">)</span>
<span class="n">bw_image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">"bw_img.jpg"</span><span class="p">)</span>
</pre>


<p><img src="https://raw.githubusercontent.com/gkabbe/Python-Kurs2015/master/images/numpy/blume_bw.jpg" alt="Blume" width="400" height="300"></p>
<p>Ein schöner Effekt kann auch erzielt werden, indem wir die Intensität jedes Farbwertes umdrehen.</p>
<pre class="code literal-block"><span></span><span class="n">pic_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"blume.JPG"</span><span class="p">))</span>
<span class="n">pic_array</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">-</span> <span class="n">pic_array</span>
<span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">pic_array</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">"komplementär.jpg"</span><span class="p">)</span>
</pre>


<p><img src="https://raw.githubusercontent.com/gkabbe/Python-Kurs2015/master/images/numpy/blume_kompl.jpg" alt="Blume" width="400" height="300"></p>
<h3>Fortgeschrittenes Beispiel: Blume umfärben</h3>
<p>In diesem etwas schwierigeren Beispiel wollen wir jetzt die Blume umfärben. Nämlich von gelb zu rot. Als erstes müssen wir dazu die gelben Stellen im Bild finden. Eine kurze \&lt;beliebige Suchmaschine&gt;-Suche wird uns zeigen, dass Gelb im RGB-Raum den Wert (255, 255, 0) hat. Wir bekommen also Gelb wenn wir Rot und Grün mischen. Es reicht nun aber nicht, den Bild-Array nur nach Pixeln zu durchsuchen, die hohe Rot- und Gelbwerte haben. Denn dann wäre auch Weiß dabei (255, 255, 255). </p>
<p>Wir machen also folgendes: wir suchen nach all den Pixeln, deren Rot- und Gelbwerte über dem Durchschnitt liegen, deren Weißwerte aber unter dem Durchschnitt liegen.</p>
<ol>
<li>Array aus Bild erzeugen:</li>
</ol>
<p>```python <br>
   from PIL import Image
   import numpy as np</p>
<p>img_arr = np.array(Image.open("blume.JPG"))
   ```</p>
<p>Unser Array hat die shape (600, 800, 3), denn das Bild ist 600 Pixel hoch und 800 Pixel breit, und jeder Pixel hat 3 Farbwerte.</p>
<ol>
<li>Durchschnitts-RGB-Werte berechnen:</li>
</ol>
<p><code>python
   mean_rgb = img_arr.mean(axis=(0, 1))</code></p>
<p>Hier mitteln wir die RGB-Werte über alle Bildpunkte, d.h. über die 0. und 1. Dimension. Das Resultat ist ein Array der shape (3,), der einen mittleren RGB-Wert des gesamten Bildes enthält.</p>
<ol>
<li>Alle Bildpunkte finden, deren Rot- und Grünwerte über den Durchschnittswerten liegen.</li>
</ol>
<p>Da wir nur an den Rot- und Grünwerten interessiert sind, müssen wir nur den Teilarray img_arr[:, :, :2] betrachten. D.h. in diesem Array fehlen die Blauwerte. </p>
<p>Schreiben wir nun </p>
<p><code>python
   img_arr[:, :, :2] &gt; mean_rgb[:2]</code></p>
<p>bekommen wir einen Array mit boolschen Werten zurück (shape: (600, 800, 2)). Diese sind über all dort True, wo entweder der Rot- <strong>oder</strong> der Grünwert über dem Durchschnittswert liegen. Das ist aber nicht was wir wollen! Wir möchten alle Pixel finden, bei denen sowohl Rot- als auch Grünwert über dem Durchschnitt liegen. Anders gesagt suchen wir in dem oberen boolschen Array alle Pixel, bei denen in der letzten Dimension nur Trues vorkommen.</p>
<p>Daher:</p>
<p><code>python
   where_is_yellow = (img_arr[:, :, :2] &gt; mean_rgb[:2]).all(axis=2)</code></p>
<p>Der resultierende boolsche Array mit der Shape (600, 800) sagt uns, an welchen Stellen des Bildes die Rot- und Grünwerte über dem Mittel liegen. </p>
<p>Darüberhinaus wollen wir aber auch nur die Stellen, bei denen der Blauwert nicht über dem Durchschnitt liegt.</p>
<p>Das können wir so ausdrücken:</p>
<p><code>python
   only_little_blue = img_arr[:, :, 2] &lt; mean_rgb[2]</code></p>
<p>Was uns jetzt noch fehlt ist eine komponentenweise <em>and</em> Verknüpfung, um nämlich einen Array zurückzubekommen, der uns für jeden Pixel sagt, ob es dort Gelb gibt <strong>und</strong> ob dort wenig blau vorkommt. </p>
<p>Selbstverständlich gibt es diese Funktion in numpy. Sie heißt dort <em>logical_and</em>:</p>
<p><code>python
   yellow_and_little_blue = np.logical_and(where_is_yellow, only_little_blue)</code></p>
<p>Nun sind wir fast fertig. Mittels <em>np.where</em> lassen wir uns die Indizes des obigen Arrays ausgeben, wo True gespeichert ist.</p>
<pre class="code literal-block"><span></span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yellow_and_little_blue</span><span class="p">)</span>
</pre>


<p>und ändern die RGB Werte an diesen Stellen zu [255, 0, 0] (was der Farbe Rot entspricht).</p>
<pre class="code literal-block"><span></span><span class="n">img_arr</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre>


<p>Schließlich speichern wir noch alles: </p>
<pre class="code literal-block"><span></span><span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">img_arr</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">"blume_rot.jpg"</span><span class="p">)</span>
</pre>


<p>Und das Ergebnis ist...</p>
<p><img src="https://raw.githubusercontent.com/gkabbe/Python-Kurs2015/master/images/numpy/blume_halbrot.jpg" alt="Blume" width="400" height="300"></p>
<p>... noch nicht ganz das, was wir uns erhofft hatten. Hier kommt nun ein bisschen Heuristik ins Spiel. Wenn wir die Zeile</p>
<pre class="code literal-block"><span></span><span class="n">where_is_yellow</span> <span class="o">=</span> <span class="p">(</span><span class="n">img_arr</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mean_rgb</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre>


<p>umändern zu</p>
<pre class="code literal-block"><span></span><span class="n">where_is_yellow</span> <span class="o">=</span> <span class="p">(</span><span class="n">img_arr</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">mean_rgb</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre>


<p>Sieht das Ergebnis...</p>
<p><img src="https://raw.githubusercontent.com/gkabbe/Python-Kurs2015/master/images/numpy/blume_rot.jpg" alt="Blume" width="400" height="300"></p>
<p>...schon wesentlich besser aus. Durch das Heruntersetzen des benötigten Gelbwertes werden nun zwar auch die Schatten rot gefärbt, aber das kann auch als Feature statt als Bug betrachtet werden...</p>
</div>
    </div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../module_exceptions/" rel="prev" title="4 - Module &amp; Exceptions">Vorheriger Eintrag</a>
            </li>
            <li class="next">
                <a href="../scipy_matplotlib/" rel="next" title="Scipy &amp; Matplotlib">Nächster Eintrag</a>
            </li>
        </ul></nav></aside></article><!--End of body content--><footer id="footer">
            Contents © 2017         <a href="mailto:gabriel.kabbe@chemie.uni-halle.de">Gabriel Kabbe</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><script src="../../assets/js/colorbox-i18n/jquery.colorbox-de.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("de");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
